# 컨테이너 적재 계획 마스터 플랜 인스턴스 파일 형식 가이드

이 문서는 `maritimelab/StowagePlanning_MasterPlanning_Benchmark` 데이터셋의 인스턴스 파일(`.txt`) 형식을 상세히 설명하는 가이드입니다. 각 데이터 항목의 의미, 순서, 자료형 등을 `instance_reader.jl` 코드와 `README.md`를 기반으로 정리했습니다.

---

## 인덱싱 규칙 (매우 중요)

이 데이터셋의 **모든 ID와 순서는 1부터 시작합니다 (1-based Indexing)**. 항구, 베이, 위치 등 모든 식별자는 0이 아닌 1부터 시작하며, 이는 데이터를 처리하는 Julia 코드의 특성과 일치합니다. 데이터의 모든 값은 이 규칙을 일관되게 따릅니다.

---

## 파일명 규칙

인스턴스 파일의 이름은 `[선박크기]_[항구수]_[리핸들비율]_[적재율]_[인스턴스ID].txt` 형식으로 구성되어 있으며, 각 요소는 다음과 같은 의미를 가집니다.

*   **선박 크기 (Vessel Size):**
    *   `S`: 소형 (Small)
    *   `M`: 중형 (Medium)
    *   `L`: 대형 (Large)
*   **항구 수 (Number of Ports):**
    *   `5`: 5개 항구
    *   `7`: 7개 항구
    *   `10`: 10개 항구
*   **리핸들 비율 (Re-handle Percentage):**
    *   `0`: 0%
    *   `15`: 15%
    *   `30`: 30%
    *   리핸들은 특정 컨테이너를 내리기 위해 위에 있는 다른 컨테이너를 임시로 옮겼다가 다시 실어야 하는 작업을 의미합니다. 이 비율은 리핸들이 필요한 컨테이너의 양을 조절하는 파라미터로 보입니다.
*   **적재율 (Loading Percentage):**
    *   `60`: 60%
    *   `70`: 70%
    *   `80`: 80%
    *   선박의 전체 적재 가능 공간 대비 실제 컨테이너가 차지하는 비율을 의미합니다.
*   **인스턴스 ID (Instance ID):**
    *   `1`, `2`: 동일한 파라미터 조합으로 생성된 여러 인스턴스를 구분하기 위한 번호입니다.

**예시:** `L_10_0_60_1.txt`
*   `L`: 대형 선박
*   `10`: 10개 항구 기항
*   `0`: 리핸들 비율 0%
*   `60`: 적재율 60%
*   `1`: 해당 조건의 첫 번째 인스턴스

---

## 파일 구조 및 데이터 항목 설명

인스턴스 파일은 일반 텍스트 파일이며, 각 줄(Line) 또는 여러 줄에 걸쳐 특정 데이터가 공백으로 구분되어 저장됩니다. 아래 설명은 파일에 기록된 데이터의 순서와 동일합니다.

### 1. 기본 정보
- **설명:** 인스턴스의 가장 기본적인 구성 정보를 정의합니다.
- **파일 내용 (1줄):** 5개의 정수 값
- **데이터 항목:**
  1. `n_ports` (Integer): 기항하는 총 항구 수
  2. `n_bays` (Integer): 선박의 총 베이(Bay, 구획) 수
  3. `n_locations` (Integer): 컨테이너를 적재할 수 있는 총 위치/블록(Location/Block) 수
  4. `n_bins` (Integer): 인접한 베이 쌍(Adjacent Bay-pair)의 수
  5. `n_container_types` (Integer): 인스턴스에서 사용되는 컨테이너 유형의 수

### 2. 갑판 위 위치 ID 목록 (`locations_over`)
- **설명:** 갑판 위에 위치한 모든 로케이션의 ID를 담고 있는 리스트입니다.
- **파일 내용 (1줄):** `n_locations` 값 중 갑판 위에 해당하는 로케이션 ID 목록 (정수)

### 3. 위치별 하부 갑판 정보 (`locations_under`)
- **설명**: 각 위치(Location)의 바로 아래에 존재하는 위치를 나타내는 구조입니다. 이 배열의 인덱스는 해당 위치의 ID이며, 그 값은 그 위치 아래에 어떤 로케이션이 존재하는지를 나타냅니다. 즉, **3차원 컨테이너 스택 구조**에서 상하 관계를 표현합니다.
- **파일 내용:** `n_locations`개의 정수로 구성된 1차원 배열 (1줄)
- **값의 의미:**
    - **양수 (e.g., 3, 5, ...):** `i`번 위치의 값이 `N`이라면, 이는 “`i`번 위치는 `N`번 위치 바로 위에 쌓인다”는 의미입니다. 일반적으로 `i`는 **갑판 위 (on-deck)** 위치이며, `N`은 **갑판 아래 (below-deck)** 위치입니다.
    - **0 (Zero):** 이 값은 해당 위치의 **아래에 아무런 다른 로케이션이 없음을 의미**합니다. 이는 곧, 해당 위치가 **해당 스택의 최하단**이라는 뜻입니다. 실제 데이터에 따르면, **갑판 아래** 위치 중에서도 위에 대응되는 위치가 없는 경우에도 `0`이 사용됩니다.
    - **-1 (Minus One):** 이 값은 **해당 위치 위에 쌓이는 갑판 위 (on-deck) 위치가 존재함을 나타냅니다.** 즉, 해당 위치는 **갑판 아래 (below-deck)** 에 있으며, 위로 이어지는 로케이션의 받침대 역할을 합니다. 이 경우, 대응되는 on-deck 위치가 `locations_over` 배열에 포함되어 있고, 해당 on-deck 위치는 이 위치 ID를 `locations_under`에서 참조합니다.

- **예시:**
  - `locations_over` 목록에 `2`번 위치가 포함되어 있고 (갑판 위),
  - `locations_under` 배열의 2번째 값이 `3`이라면,
  - 이는 **"2번 위치는 3번 위치 바로 위에 쌓인다"**는 의미입니다.
  - 이때 3번 위치는 갑판 아래(`below-deck`)에 있으며, `locations_under` 배열의 3번째 값은 `-1`입니다.
  - | 값   | 의미 |
|------|------|
| 양수 | 아래에 다른 로케이션이 있음 (on-deck일 가능성 높음) |
| 0    | 아래에 아무 로케이션 없음 (최하단) |
| -1   | 갑판 아래에 있으며 위에 on-deck 위치 존재함 (받침대 역할) |

### 4. 베이별 갑판 위 위치 목록 (`locations_over_in_bay`)
- **설명:** 각 베이에 속한 갑판 위 로케이션들의 ID 목록입니다.
- **파일 내용 (`n_bays`줄):** 각 줄은 해당 베이에 속한 갑판 위 로케이션 ID들을 나열합니다.

### 5. 위치별 소속 베이 정보 (`location_bay`)
- **설명:** 각 로케이션이 어느 베이에 속해 있는지를 나타내는 정보입니다.
- **파일 내용 (1줄):** `n_locations`개의 정수 값 목록 (각 값은 베이 ID)

### 6. 위치별 용량 정보
- **설명:** 각 로케이션의 물리적, 기능적 용량을 정의합니다. 여기서 **Location은 단일 컨테이너 슬롯이 아니라, 여러 슬롯이 모여 있는 하나의 '블록(Block)' 또는 '구역'을 의미**하는 경우가 많습니다. 이 때문에 TEU와 FEU 용량 관계가 단순 2:1이 아닐 수 있습니다.
- **파일 내용 (4줄):** 각 줄은 `n_locations`개의 값을 가집니다.
  1. `location_TEU_capacity` (Integer): 각 로케이션의 TEU (20피트 컨테이너) 기준 최대 적재 가능 개수
  2. `location_FEU_capacity` (Integer): 각 로케이션의 FEU (40피트 컨테이너) 기준 최대 적재 가능 개수
  3. `location_reefer_capacity` (Integer): 각 로케이션에 있는 냉동 컨테이너 전원 연결구(Reefer Plug)의 수
  4. `location_weight_capacity` (Float): 각 로케이션의 최대 적재 가능 중량 (단위: 톤)

- **TEU와 FEU 용량의 관계 심층 분석:**
  - **기본 개념:** 컨테이너선에는 컨테이너를 끼워 넣는 물리적인 '셀(Cell)' 또는 '슬롯(Slot)'이 있습니다. 이 슬롯은 보통 20피트 또는 40피트 길이에 맞춰 설계됩니다.
  - **주차장 비유:** 선박의 한 구역(Location)을 주차장이라고 생각할 수 있습니다. 이 주차장에는 '소형차(20ft) 전용칸'과 '버스(40ft) 전용칸'이 섞여 있습니다.
    - `location_TEU_capacity`는 이 주차장에 소형차를 최대 몇 대나 주차할 수 있는지를 나타냅니다. (버스 칸에 소형차 2대를 댈 수 있다면 그것까지 계산해서)
    - `location_FEU_capacity`는 버스를 최대 몇 대나 주차할 수 있는지를 나타냅니다. (소형차 전용칸에는 버스를 댈 수 없습니다.)
  - **왜 FEU 용량이 TEU의 절반이 아닐까?**
    1.  **40피트 전용 슬롯:** 어떤 슬롯은 물리적으로 40피트 컨테이너 하나만 받도록 설계될 수 있습니다. 이런 슬롯에는 40피트 컨테이너(1 FEU) 1개를 넣을 수 있지만, 20피트 컨테이너(TEU)는 2개가 아니라 1개만 들어갈 수도 있습니다. (중간에 고정 장치가 없거나 구조적으로 불안정해서). 이 경우 이 슬롯의 용량은 `1 FEU`, `1 TEU`가 됩니다.
    2.  **20피트 전용 슬롯:** 선박의 특정 구역(주로 가장자리)에는 40피트 컨테이너가 들어갈 수 없는 20피트 전용 슬롯만 있을 수 있습니다. 이 슬롯의 용량은 `0 FEU`, `1 TEU`가 됩니다.
    3.  **슬롯의 조합:** 하나의 `Location`은 위와 같은 다양한 종류의 슬롯들이 섞여 있는 '블록'입니다. 예를 들어 한 Location이 [1 FEU, 1 TEU] 용량의 40피트 슬롯 10개와 [0 FEU, 1 TEU] 용량의 20피트 슬롯 4개로 구성되어 있다면:
        - 총 `location_FEU_capacity` = 10 * 1 + 4 * 0 = **10**
        - 총 `location_TEU_capacity` = 10 * 1 + 4 * 1 = **14**
        - 이처럼 TEU 용량이 FEU 용량의 2배가 아닌, 복잡한 관계를 가지게 됩니다.

  결론적으로, **`location_TEU_capacity`와 `location_FEU_capacity`는 해당 구역(Location)을 구성하는 물리적인 슬롯들의 특성을 종합하여 계산된 값**으로 이해해야 합니다.

### 7. 위치별 무게 중심 정보
- **설명:** 각 로케이션의 3차원 무게 중심 좌표입니다. 선박의 안정성 계산에 사용됩니다. 이 좌표계는 선박의 특정 지점을 원점(0,0,0)으로 하는 3차원 직교 좌표계입니다.
- **파일 내용 (3줄):** 각 줄은 `n_locations`개의 값을 가집니다. (단위: 미터)

- **좌표계 해석:**
  - **원점(Origin):** 보통 선박의 가장 낮은 지점(용골, Keel), 선미 수선(Aft Perpendicular), 그리고 선박 중심선(Centerline)이 만나는 점을 기준으로 합니다.
  1. **`location_lcg` (Float) - 종방향(Longitudinal, X축):** 선박의 길이 방향 무게 중심입니다. 원점에서 선수(앞쪽) 방향이 `+`, 선미(뒤쪽) 방향이 `-`가 됩니다.
  2. **`location_vcg` (Float) - 수직(Vertical, Z축):** 선박의 높이 방향 무게 중심입니다. 선박의 가장 밑바닥(기선, Keel)이 `0`이며, 위로 올라갈수록 값이 커집니다. 항상 양수입니다.
  3. **`location_tcg` (Float) - 횡방향(Transversal, Y축):** 선박의 폭 방향 무게 중심입니다. 선박의 좌우 중심선이 `0`이며, 보통 우현(오른쪽)이 `+`, 좌현(왼쪽)이 `-`가 됩니다.

### 8. 항구별, 베이별 부력 (`bay_buoyancy`)
- **설명:** 각 항구(마지막 항구 제외)에서 출항하기 직전 상태에서, 각 베이가 받는 부력의 크기입니다. **이 값은 최종 결과가 아닌, 안정성 계산을 위한 입력(Input) 파라미터입니다.**
- **파일 내용 (`n_ports - 1`줄):** 각 줄은 `n_bays`개의 부력 값(Float)을 가집니다. (단위: 톤)
- **시점 및 의미 상세 설명:**
  - **시점:** `P`번 항구에서 하역/선적 작업을 모두 마친 후, 다음 항구(`P+1`)로 **출항하기 직전**의 상태를 기준으로 합니다.
  - **단순화된 입력값:** 실제 부력은 적재 상태에 따라 변하는 결과값이지만, 이 벤치마크에서는 문제의 복잡도를 낮추기 위해 특정 기준 상태의 부력을 미리 계산하여 **고정된 입력값으로 제공**합니다. 모델은 이 값을 사용하여 컨테이너 적재 시 발생하는 각종 힘(전단력, 굽힘 모멘트)이 제약 조건을 만족하는지 검사해야 합니다.
  - 이런 이유로, 더 이상 다음 항해 구간이 없는 **마지막 항구(`n_ports`)에 대한 부력 데이터는 존재하지 않습니다.**

### 9. 인접 베이 쌍 목록 (`bay_bins`)
- **설명:** 안정성 계산 시 함께 고려되어야 할 **인접 베이들의 '쌍(Pair)' 목록**입니다. **각 줄이 하나의 독립된 인접 관계**를 나타냅니다.
- **파일 내용 (`n_bins`줄):** 각 줄은 인접한 두 베이의 ID(Integer)를 가집니다.
- **해석 방법 (매우 중요):**
  - 이 목록은 특정 베이의 모든 이웃을 나열하는 것이 아닙니다. **각 줄은 단 하나의 '인접 쌍' 정보**를 담고 있습니다.
  - 예를 들어, 목록의 첫 줄에 `2 3`이라고 적혀 있다면, 이것은 **'1번 베이'에 대한 정보가 아니라, '2번 베이와 3번 베이가 서로 인접해 있다'는 하나의 사실**을 의미합니다.
  - 그 다음 줄에 `3 4`가 있다면, 이는 '3번 베이와 4번 베이가 인접해 있다'는 또 다른 사실을 나타냅니다.
  - 따라서 선박 전체의 인접 관계를 파악하려면 이 목록 전체를 확인해야 합니다. 예를 들어 3번 베이의 인접 베이를 찾으려면, 목록에서 3이 포함된 모든 쌍(e.g., `2 3`, `3 4`)을 찾아야 합니다.
  - 선박의 물리적 구조에 따라, 전단력/굽힘 모멘트 계산이 필요 없는 구간(예: 가장 끝쪽 베이와 그 다음 베이 사이)은 이 목록에서 생략될 수도 있습니다.

### 10. 베이별 경하 중량 (`bay_lightship_weight`)
- **설명:** 컨테이너가 하나도 실려있지 않은 상태(경하 상태)에서 각 베이 자체의 고정된 무게입니다.
- **파일 내용 (1줄):** `n_bays`개의 중량 값(Float)을 가집니다. (단위: 톤)

### 11. 베이별 무게 중심 정보
- **설명:** 각 베이 자체의 3차원 무게 중심 좌표입니다.
- **파일 내용 (3줄):** 각 줄은 `n_bays`개의 값을 가집니다. (단위: 미터)
  1. `bay_lcg` (Float): 종방향 무게 중심
  2. `bay_vcg` (Float): 수직 무게 중심
  3. `bay_tcg` (Float): 횡방향 무게 중심

### 12. 베이별 안정성 제약 조건
- **설명:** 선박의 구조적 안전을 위해 각 베이 **사이**에 가해질 수 있는 힘의 한계를 정의합니다. 이 값들은 보통 `bay_bins`로 정의된 인접 베이 쌍 사이에 적용됩니다.
- **파일 내용 (3줄):** 각 줄은 `n_bins`개(또는 관련 개수)의 값을 가집니다.
  1. `bay_min_shear` (Float): 최소 전단력 (단위: 톤)
  2. `bay_max_shear` (Float): 최대 전단력 (단위: 톤)
  3. `bay_max_bending` (Float): 최대 굽힘 모멘트 (단위: 톤/미터)

#### 용어 설명 (전단력과 굽힘 모멘트)
- **전단력 (Shear Force):** 물체를 가위처럼 **자르려고 하는 힘**입니다. 선박의 특정 단면을 기준으로, 한쪽은 위로, 다른 한쪽은 아래로 힘이 작용하여 선체가 엇갈리며 파괴되는 것을 방지하기 위한 제약 조건입니다.
- **굽힘 모멘트 (Bending Moment):** 물체를 막대기처럼 **휘게 만드는 힘의 크기**입니다. 파도 등으로 인해 선박의 특정 부분이 활처럼 휘어 변형되거나 파괴되는 것을 방지하기 위한 제약 조건입니다.

#### 굽힘 모멘트 계산과 거리(Distance)
- 굽힘 모멘트는 `힘 × 거리`로 계산됩니다. 이 데이터셋에서 거리는 별도의 값으로 주어지지 않으며, **무게 중심 데이터로부터 직접 계산**해야 합니다.
- 예를 들어, 두 베이(A, B) 사이의 거리는 각 베이의 종방향 무게 중심(`bay_lcg`) 값의 차이, 즉 **`abs(bay_lcg[A] - bay_lcg[B])`** 와 같이 계산할 수 있습니다. 알고리즘은 이러한 위치 정보를 바탕으로 거리를 유추하고, 힘(무게, 부력)을 곱하여 굽힘 모멘트를 계산한 뒤, `bay_max_bending` 제약 조건을 만족하는지 확인해야 합니다.

### 13. 항구별 목표 배수량 (`displacement`)
- **설명:** 각 항구(마지막 항구 제외)를 **출항할 때의 목표 총 중량(배수량)**을 의미합니다. 이는 안정성 계산의 제약 조건으로 사용됩니다.
- **파일 내용 (1줄):** `n_ports - 1`개의 배수량 값(Float)을 가집니다. (단위: 톤)
- **배수량과 선박평형수의 관계:**
  - **배수량의 구성:** 선박의 총 무게(배수량)는 `선박 자체 무게(경하중량) + 화물 무게 + 기타(연료, 청수, 선박평형수 등)`로 구성됩니다.
  - **목표치로서의 배수량:** 이 데이터의 `displacement` 값은 솔버가 결정해야 할 결과가 아니라, **주어진 제약 조건**입니다. 즉, "이번 항차에서는 이 항구를 떠날 때, 선박의 총 무게를 이 값에 맞춰야 한다"는 목표치를 의미합니다.
  - **솔버의 과제:** 솔버는 컨테이너를 배치하여 '화물 무게'를 결정합니다. 이때, 선박 자체 무게, 화물 무게, 그리고 연료나 선박평형수 등 기타 무게의 총합이 주어진 `displacement` 값을 초과하지 않도록 계획을 수립해야 합니다. 즉, 이 값은 선박평형수 조절까지 감안하여 설정된 **총 무게의 한계치**로 해석할 수 있습니다.

### 14. 항구별 선박 무게 중심 한계
- **설명:** 각 항구(마지막 항구 제외)에서 선박 전체가 유지해야 하는 무게 중심의 허용 범위입니다.
- **파일 내용 (5줄):** 각 줄은 `n_ports - 1`개의 값을 가집니다. (단위: 미터)
  1. `ship_min_lcg` (Float): 선박 전체의 최소 종방향 무게 중심
  2. `ship_max_lcg` (Float): 선박 전체의 최대 종방향 무게 중심
  3. `ship_max_vcg` (Float): 선박 전체의 최대 수직 무게 중심
  4. `ship_min_tcg` (Float): 선박 전체의 최소 횡방향 무게 중심
  5. `ship_max_tcg` (Float): 선박 전체의 최대 횡방향 무게 중심

#### 선박 전체 무게 중심 계산 방법
- 선박 전체의 무게 중심은 **'모멘트의 합' 원리(가중 평균)**를 사용하여 계산합니다. 이는 컨테이너를 포함한 선박 위의 모든 무게 요소들을 고려해야 함을 의미합니다.
- **기본 공식:** `전체 무게 중심 = (Σ (개별 무게 × 개별 무게 중심)) / (Σ 개별 무게)`

- **계산 단계 (LCG 예시):**
  1.  **선박 자체의 모멘트 계산:** 모든 베이(`i`)에 대해 `bay_lightship_weight[i] × bay_lcg[i]`를 계산하여 모두 더합니다.
  2.  **화물(컨테이너)의 모멘트 계산:** 선박에 실린 모든 컨테이너(`c`)에 대해, 해당 컨테이너의 무게(`c.weight`)와 컨테이너가 놓인 위치의 LCG(`location_lcg[c.location]`)를 곱하여 모두 더합니다.
  3.  **총 모멘트:** `(1번 값) + (2번 값)`
  4.  **총 무게:** `(모든 bay_lightship_weight의 합) + (모든 컨테이너 무게의 합)`
  5.  **최종 LCG:** `(3번 값) / (4번 값)`

- **VCG, TCG 계산:** 수직(`VCG`), 횡방향(`TCG`) 무게 중심 또한 위와 동일한 구조의 공식으로 계산됩니다. 각 공식에서 `lcg` 대신 `vcg` 또는 `tcg` 값을 사용하면 됩니다.
- **제약 조건 확인:** 이렇게 계산된 `LCG_ship`, `VCG_ship`, `TCG_ship` 값이 위에서 정의된 각 항구의 한계 범위 안에 들어가는지 확인해야 합니다.

### 15. 컨테이너 유형 정의 (`container_types`)
- **설명:** 인스턴스에서 사용되는 모든 컨테이너 유형의 상세 속성을 정의합니다.
- **파일 내용 (`n_container_types`줄):** 각 줄은 하나의 컨테이너 유형을 정의합니다.
  - **구성:** `길이(Int)` `무게(Float)` `종류(String)`
  - **종류 (Type) 값:**
    - `DC`: 일반 컨테이너 (Dry Container)
    - `HC`: 하이큐브 컨테이너 (High-Cube Container)
    - `RC`: 냉동 컨테이너 (Reefer Container)
    - `HR`: 하이큐브 냉동 컨테이너 (High-Cube Reefer)

### 16. 운송 구간별 컨테이너 수량 (`containers`)
- **설명:** 각 운송 구간(선적항 -> 양하항)별로 운송해야 할 컨테이너의 수량을 **유형별로** 정의합니다.
- **파일 내용 (각 유효한 구간마다 1줄):**
  - **구성:** `선적항ID` `양하항ID` `유형1개수` `유형2개수` ...
  - 선적항(Origin) ID는 양하항(Destination) ID보다 항상 작습니다.
- **컨테이너 속성(무게, 크기) 확인 방법:**
  - 이 섹션의 값들은 **컨테이너의 개수**만을 나타냅니다. 각 컨테이너의 실제 무게, 크기, 종류 등의 속성을 확인하려면, **해당 순서(인덱스)를 가지고 바로 위 `[15. 컨테이너 유형 정의]` 섹션을 참조**해야 합니다.
  - 예를 들어, 이 섹션의 한 줄에서 4번째 숫자(즉, 2번 유형의 컨테이너 개수)가 8개라면, 이 8개 컨테이너의 무게는 `container_types` 목록의 2번째 줄에 정의된 무게 값을 따릅니다.

### 17. 초기 선적 컨테이너 정보 (`release`)
- **설명:** 계획 시작 시점(첫 항구)에 이미 선박에 실려 있는 컨테이너의 정보입니다.
- **파일 내용 (각 (양하항, 로케이션) 조합마다 1줄):**
  - **구성:** `양하항ID` `로케이션ID` `유형1개수` `유형2개수` ...
  - 이 데이터는 첫 항구를 제외한 모든 양하항과 모든 로케이션의 조합에 대해 주어집니다.
