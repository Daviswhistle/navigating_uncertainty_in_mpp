# 컨테이너 적재 계획 마스터 플랜 인스턴스 파일 형식 가이드

이 문서는 `maritimelab/StowagePlanning_MasterPlanning_Benchmark` 데이터셋의 인스턴스 파일(`.txt`) 형식을 상세히 설명하는 가이드입니다. 각 데이터 항목의 의미, 순서, 자료형 등을 `instance_reader.jl` 코드와 `README.md`를 기반으로 정리했습니다.

---

## 인덱싱 규칙 (매우 중요)

이 데이터셋의 **모든 ID와 순서는 1부터 시작합니다 (1-based Indexing)**. 항구, 베이, 위치 등 모든 식별자는 0이 아닌 1부터 시작하며, 이는 데이터를 처리하는 Julia 코드의 특성과 일치합니다. 데이터의 모든 값은 이 규칙을 일관되게 따릅니다.

---

## 파일명 규칙

인스턴스 파일의 이름은 `[선박크기]_[항구수]_[기적재율]_[선박 활용률]_[인스턴스ID].txt` 형식으로 구성되어 있습니다.

**예시:** `L_10_0_60_1.txt`
*   `L`: 대형 선박
*   `10`: 10개 항구 기항
*   `0`: 기적재율 0%
*   `60`: 선박 활용률 60%
*   `1`: 해당 조건의 첫 번째 인스턴스

---

## 파일 구조 및 데이터 항목 설명

인스턴스 파일은 일반 텍스트 파일이며, 각 줄(Line) 또는 여러 줄에 걸쳐 특정 데이터가 공백으로 구분되어 저장됩니다. 아래 설명은 파일에 기록된 데이터의 순서와 동일합니다.

### 1. 기본 정보
- **설명:** 인스턴스의 가장 기본적인 구성 정보를 정의합니다.
- **파일 내용 (1줄):** 5개의 정수 값
- **데이터 항목:**
  1. `n_ports` (Integer): 기항하는 총 항구 수
  2. `n_bays` (Integer): 선박의 총 베이(Bay, 구획) 수
  3. `n_locations` (Integer): 컨테이너를 적재할 수 있는 총 위치/블록(Location/Block) 수
  4. `n_bins` (Integer): 인접한 베이 쌍(Adjacent Bay-pair)의 수
  5. `n_container_types` (Integer): 인스턴스에서 사용되는 컨테이너 유형의 수

### 2. 갑판 위 위치 ID 목록 (`locations_over`)
- **설명:** 갑판 위에 위치한 모든 로케이션의 ID를 담고 있는 리스트입니다.
- **파일 내용 (1줄):** `n_locations` 값 중 갑판 위에 해당하는 로케이션 ID 목록 (정수)

### 3. 위치별 하부 갑판 정보 (`locations_under`)
- **설명**: 각 위치(Location)의 바로 아래에 존재하는 위치를 나타내는 구조입니다. 이 배열의 인덱스는 해당 위치의 ID이며, 그 값은 그 위치 아래에 어떤 로케이션이 존재하는지를 나타냅니다. 즉, **3차원 컨테이너 스택 구조**에서 상하 관계를 표현합니다.
- **파일 내용:** `n_locations`개의 정수로 구성된 1차원 배열 (1줄)
- **값의 의미:**
    - **양수 (e.g., 3, 5, ...):** `i`번 위치의 값이 `N`이라면, 이는 “`i`번 위치는 `N`번 위치 바로 위에 쌓인다”는 의미입니다. 일반적으로 `i`는 **갑판 위 (on-deck)** 위치이며, `N`은 **갑판 아래 (below-deck)** 위치입니다.
    - **0 (Zero):** 이 값은 해당 위치의 **아래에 아무런 다른 로케이션이 없음을 의미**합니다. 이는 곧, 해당 위치가 **해당 스택의 최하단**이라는 뜻입니다.
    - **-1 (Minus One):** 이 값은 **해당 위치 위에 쌓이는 갑판 위 (on-deck) 위치가 존재함을 나타냅니다.** 즉, 해당 위치는 **갑판 아래 (below-deck)** 에 있으며, 위로 이어지는 로케이션의 받침대 역할을 합니다. 이 경우, 대응되는 on-deck 위치가 `locations_over` 배열에 포함되어 있고, 해당 on-deck 위치는 이 위치 ID를 `locations_under`에서 참조합니다.

- **예시:**
  - `locations_over` 목록에 `2`번 위치가 포함되어 있고 (갑판 위),
  - `locations_under` 배열의 2번째 값이 `3`이라면,
  - 이는 2번 위치는 3번 위치 위에 있다는 의미입니다.
  - 이때 3번 위치는 갑판 아래(`below-deck`)에 있으며, `locations_under` 배열의 3번째 값은 `-1`입니다.

### 4. 베이별 갑판 위 위치 목록 (`locations_over_in_bay`)
- **설명:** 각 베이에 속한 갑판 위 로케이션들의 ID 목록입니다.
- **파일 내용 (`n_bays`줄):** 각 줄은 해당 베이에 속한 갑판 위 로케이션 ID들을 나열합니다.

### 5. 위치별 소속 베이 정보 (`location_bay`)
- **설명:** 각 로케이션이 어느 베이에 속해 있는지를 나타내는 정보입니다.
- **파일 내용 (1줄):** `n_locations`개의 정수 값 목록 (각 값은 베이 ID)

### 6. 위치별 용량 정보
- **설명:** 각 로케이션의 물리적, 기능적 용량을 정의합니다. 여기서 **Location은 단일 컨테이너 슬롯이 아니라, 여러 슬롯이 모여 있는 하나의 '블록(Block)' 또는 '구역'을 의미**합니다. 이 때문에 TEU와 FEU 용량 관계가 단순 2:1이 아닐 수 있습니다.
- **파일 내용 (4줄):** 각 줄은 `n_locations`개의 값을 가집니다.
  1. `location_TEU_capacity` (Integer): 각 로케이션의 TEU (20피트 컨테이너) 기준 최대 적재 가능 개수
  2. `location_FEU_capacity` (Integer): 각 로케이션의 FEU (40피트 컨테이너) 기준 최대 적재 가능 개수
  3. `location_reefer_capacity` (Integer): 각 로케이션에 있는 냉동 컨테이너 전원 연결구(Reefer Plug)의 수
  4. `location_weight_capacity` (Float): 각 로케이션의 최대 적재 가능 중량 (단위: 톤)

  ---

  #### TEU와 FEU 기본 정의

  | 구분 | TEU (20ft) | FEU (40ft) |
  |------|------------|------------|
  | 길이 | 20피트 (6.1m) | 40피트 (12.2m) |
  | 폭 | 8피트 (2.4m) | 8피트 (2.4m) |
  | 높이 | 8.5피트 (2.6m) | 8.5피트 (2.6m) |
  | 내부 부피 | 약 38.5㎥ | 약 77㎥ |
  | 최대 총중량 | 약 24톤 | 약 30.5톤 |

  - TEU: Twenty-foot Equivalent Unit (20피트 컨테이너 1개)
  - FEU: Forty-foot Equivalent Unit (40피트 컨테이너 1개)

  ---

  #### 단순 2:1 비율이 아닌 이유

  1. **중량 차이**:  
    FEU는 길이로는 TEU의 2배지만, 무게 용량은 약 1.25배 수준입니다. (30.5톤 vs 24톤)

  2. **슬롯 호환성**:  
    일부 슬롯은 40피트만 수용 가능하거나, 20피트를 두 개 넣기엔 구조적 제약이 있습니다.

  3. **로케이션은 다양한 슬롯 조합**:  
    하나의 로케이션이 다음과 같은 구성일 수 있습니다:
    - 40ft 슬롯 10개 → `10 TEU`, `10 FEU`
    - 20ft 전용 슬롯 4개 → `4 TEU`, `0 FEU`  
    → 이 로케이션의 용량: `TEU = 14`, `FEU = 10`

  ---

  #### 실무 차이 요약

  | 항목 | TEU | FEU |
  |------|-----|-----|
  | **유연성** | 2개로 분리 가능 → 다중 목적지 적재 유리 | 단일 유닛으로 간편 적재 |
  | **비용 효율** | 단가 높음, 소형 화물에 적합 | 대형화물·장거리 운송에 유리 |
  | **선박 적재 최적화** | 슬롯 단위로 유연함 | 효율적 스태킹 가능 |
  | **하역 장비 호환성** | 대부분 호환 | 일부 항만 제약 발생 가능 |

  ---

  #### 결론

  - `location_TEU_capacity`와 `location_FEU_capacity`는 단순히 2:1 비율로 변환되는 값이 아닙니다.
  - 실제 선박 구조, 슬롯 설계, 컨테이너 유형 제한, 무게 제한 등을 종합 반영한 물리적 결과입니다.
  - 특히 **로케이션 단위의 설계는 혼합 슬롯 기반으로 이해**해야 하며, TEU/FEU는 적재 효율성과 유연성 면에서 서로 상호 보완적인 의미를 가집니다.

### 7. 위치별 무게 중심 정보
- **설명:** 각 로케이션의 3차원 무게 중심 좌표입니다. 선박의 안정성 계산에 사용됩니다. 이 좌표계는 선박의 특정 지점을 원점(0,0,0)으로 하는 3차원 직교 좌표계입니다.
- **파일 내용 (3줄):** 각 줄은 `n_locations`개의 값을 가집니다. (단위: 미터)

- **좌표계 해석:**
  - **원점(Origin):** 보통 선박의 가장 낮은 지점(용골, Keel), 선미 수선(Aft Perpendicular), 그리고 선박 중심선(Centerline)이 만나는 점을 기준으로 합니다.
  1. **`location_lcg` (Float) - 종방향(Longitudinal, X축):** 선박의 길이 방향 무게 중심입니다. 원점에서 선수(앞쪽) 방향이 `+`, 선미(뒤쪽) 방향이 `-`가 됩니다.
  2. **`location_vcg` (Float) - 수직(Vertical, Z축):** 선박의 높이 방향 무게 중심입니다. 선박의 가장 밑바닥(기선, Keel)이 `0`이며, 위로 올라갈수록 값이 커집니다. 항상 양수입니다.
  3. **`location_tcg` (Float) - 횡방향(Transversal, Y축):** 선박의 폭 방향 무게 중심입니다. 선박의 좌우 중심선이 `0`이며, 보통 우현(오른쪽)이 `+`, 좌현(왼쪽)이 `-`가 됩니다.

### 8. 항구별, 베이별 부력 (`bay_buoyancy`)
- **설명:** 각 항구(마지막 항구 제외)에서 출항하기 직전 상태에서, 각 베이가 받는 부력의 크기입니다. **이 값은 최종 결과가 아닌, 안정성 계산을 위한 입력(Input) 파라미터입니다.**
- **파일 내용 (`n_ports - 1`줄):** 각 줄은 `n_bays`개의 부력 값(Float)을 가집니다. (단위: 톤)
- **시점 및 의미 상세 설명:**
  - **시점:** `P`번 항구에서 하역/선적 작업을 모두 마친 후, 다음 항구(`P+1`)로 **출항하기 직전**의 상태를 기준으로 합니다.
  - **단순화된 입력값:** 실제 부력은 적재 상태에 따라 변하는 결과값이지만, 이 벤치마크에서는 문제의 복잡도를 낮추기 위해 특정 기준 상태의 부력을 미리 계산하여 **고정된 입력값으로 제공**합니다. 모델은 이 값을 사용하여 컨테이너 적재 시 발생하는 각종 힘(전단력, 굽힘 모멘트)이 제약 조건을 만족하는지 검사해야 합니다.
  - 이런 이유로, 더 이상 다음 항해 구간이 없는 **마지막 항구(`n_ports`)에 대한 부력 데이터는 존재하지 않습니다.**

### 9. 인접 베이 쌍 목록 (`bay_bins`)
- **설명:** 안정성 계산 시 함께 고려되어야 할 **인접 베이들의 '쌍(Pair)' 목록**입니다. **각 줄이 하나의 독립된 인접 관계**를 나타냅니다.
- **파일 내용 (`n_bins`줄):** 각 줄은 인접한 두 베이의 ID(Integer)를 가집니다.
- **해석 방법 (매우 중요):**
  - 이 목록은 특정 베이의 모든 이웃을 나열하는 것이 아닙니다. **각 줄은 단 하나의 '인접 쌍' 정보**를 담고 있습니다.
  - 예를 들어, 목록의 첫 줄에 `2 3`이라고 적혀 있다면, 이것은 **'1번 베이'에 대한 정보가 아니라, '2번 베이와 3번 베이가 서로 인접해 있다'는 하나의 사실**을 의미합니다.
  - 그 다음 줄에 `3 4`가 있다면, 이는 '3번 베이와 4번 베이가 인접해 있다'는 또 다른 사실을 나타냅니다.
  - 따라서 선박 전체의 인접 관계를 파악하려면 이 목록 전체를 확인해야 합니다. 예를 들어 3번 베이의 인접 베이를 찾으려면, 목록에서 3이 포함된 모든 쌍(e.g., `2 3`, `3 4`)을 찾아야 합니다.
  - 선박의 물리적 구조에 따라, 전단력/굽힘 모멘트 계산이 필요 없는 구간(예: 가장 끝쪽 베이와 그 다음 베이 사이)은 이 목록에서 생략될 수도 있습니다.

### 10. 베이별 경하 중량 (`bay_lightship_weight`)
- **설명:** 컨테이너가 하나도 실려있지 않은 상태(경하 상태)에서 각 베이 자체의 고정된 무게입니다.
- **파일 내용 (1줄):** `n_bays`개의 중량 값(Float)을 가집니다. (단위: 톤)

### 11. 베이별 무게 중심 정보
- **설명:** 각 베이 자체의 3차원 무게 중심 좌표입니다.
- **파일 내용 (3줄):** 각 줄은 `n_bays`개의 값을 가집니다. (단위: 미터)
  1. `bay_lcg` (Float): 종방향 무게 중심
  2. `bay_vcg` (Float): 수직 무게 중심
  3. `bay_tcg` (Float): 횡방향 무게 중심

### 12. 베이별 안정성 제약 조건
- **설명:** 선박의 구조적 안전을 위해 각 베이 **사이**에 가해질 수 있는 힘의 한계를 정의합니다. 이 값들은 보통 `bay_bins`로 정의된 인접 베이 쌍 사이에 적용됩니다.
- **파일 내용 (3줄):** 각 줄은 `n_bins`개(또는 관련 개수)의 값을 가집니다.
  1. `bay_min_shear` (Float): 최소 전단력 (단위: 톤)
  2. `bay_max_shear` (Float): 최대 전단력 (단위: 톤)
  3. `bay_max_bending` (Float): 최대 굽힘 모멘트 (단위: 톤/미터)

#### 용어 설명 (전단력과 굽힘 모멘트)
- **전단력 (Shear Force):** 물체를 가위처럼 **자르려고 하는 힘**입니다. 선박의 특정 단면을 기준으로, 한쪽은 위로, 다른 한쪽은 아래로 힘이 작용하여 선체가 엇갈리며 파괴되는 것을 방지하기 위한 제약 조건입니다.
- **굽힘 모멘트 (Bending Moment):** 물체를 막대기처럼 **휘게 만드는 힘의 크기**입니다. 파도 등으로 인해 선박의 특정 부분이 활처럼 휘어 변형되거나 파괴되는 것을 방지하기 위한 제약 조건입니다.

#### 전단력 (Shear Force) 계산

전단력은 특정 단면을 기준으로 한쪽의 모든 수직 힘의 합입니다. 선박에서는 보통 선수(앞)에서부터 각 베이의 경계면까지의 힘을 누적하여 계산합니다.

- **계산 대상:** `bay_bins`에 정의된 각 인접 베이 쌍 사이의 단면

#### 특정 단면에서의 전단력 계산 예시:

`i`번 베이와 `i+1`번 베이 사이의 단면에서 전단력을 계산하려면, 선박의 한쪽 끝(예: 1번 베이)부터 `i`번 베이까지의 모든 수직 힘을 더합니다.

- **수직 힘의 종류:**
  1.  **부력 (위로 작용, +):** `bay_buoyancy`
  2.  **중력 (아래로 작용, -):**
      -   베이 자체 무게: `bay_lightship_weight`
      -   컨테이너 무게: `container.weight`

- **계산 공식:**
  `전단력 = Σ(1~i번 베이의 부력) - Σ(1~i번 베이의 경하 중량) - Σ(1~i번 베이에 실린 모든 컨테이너의 무게)`

- **제약 조건 확인:** 이렇게 계산된 전단력 값이 **[12. 베이별 안정성 제약 조건]**의 `bay_min_shear`와 `bay_max_shear` 값 사이에 있는지 확인해야 합니다.
  
#### 굽힘 모멘트 계산과 거리(Distance)
- 굽힘 모멘트는 `힘 × 거리`로 계산됩니다. 이 데이터셋에서 거리는 별도의 값으로 주어지지 않으며, **무게 중심 데이터로부터 직접 계산**해야 합니다.
- 예를 들어, 두 베이(A, B) 사이의 거리는 각 베이의 종방향 무게 중심(`bay_lcg`) 값의 차이, 즉 **`abs(bay_lcg[A] - bay_lcg[B])`** 와 같이 계산할 수 있습니다. 알고리즘은 이러한 위치 정보를 바탕으로 거리를 유추하고, 힘(무게, 부력)을 곱하여 굽힘 모멘트를 계산한 뒤, `bay_max_bending` 제약 조건을 만족하는지 확인해야 합니다.

### 13. 항구별 목표 배수량 (`displacement`)
- **설명:** 각 항구(마지막 항구 제외)를 출항할 때의 목표 총 중량(배수량)을 의미합니다. 이는 안정성 계산의 제약 조건으로 사용됩니다.
- **파일 내용 (1줄):** `n_ports - 1`개의 배수량 값(Float)을 가집니다. (단위: 톤)
- **배수량과 선박평형수의 관계:**
  - **배수량의 구성:** 선박의 총 무게(배수량)는 `선박 자체 무게(경하중량) + 화물 무게 + 기타(연료, 청수, 선박평형수 등)`로 구성됩니다.
  - **목표치로서의 배수량:** 이 데이터의 `displacement` 값은 솔버가 결정해야 할 결과가 아니라, **주어진 제약 조건**입니다. 즉, "이번 항차에서는 이 항구를 떠날 때, 선박의 총 무게를 이 값에 맞춰야 한다"는 목표치를 의미합니다.
  - **솔버의 과제:** 솔버는 컨테이너를 배치하여 '화물 무게'를 결정합니다. 이때, 선박 자체 무게, 화물 무게, 그리고 연료나 선박평형수 등 기타 무게의 총합이 주어진 `displacement` 값을 초과하지 않도록 계획을 수립해야 합니다. 즉, 이 값은 선박평형수 조절까지 감안하여 설정된 **총 무게의 한계치**로 해석할 수 있습니다.

### 14. 항구별 선박 무게 중심 한계
- **설명:** 각 항구(마지막 항구 제외)에서 선박 전체가 유지해야 하는 무게 중심의 허용 범위입니다. **이 한계값을 해석하는 기준점(원점)은 [7. 위치별 무게 중심 정보]에서 설명된 선박의 전역 좌표계와 동일합니다.**
- **파일 내용 (5줄):** 각 줄은 `n_ports - 1`개의 값을 가집니다. (단위: 미터)
  1. `ship_min_lcg` (Float): 선박 전체의 최소 종방향 무게 중심
  2. `ship_max_lcg` (Float): 선박 전체의 최대 종방향 무게 중심
  3. `ship_max_vcg` (Float): 선박 전체의 최대 수직 무게 중심
  4. `ship_min_tcg` (Float): 선박 전체의 최소 횡방향 무게 중심
  5. `ship_max_tcg` (Float): 선박 전체의 최대 횡방향 무게 중심

#### 선박 전체 무게 중심 계산 방법
- 선박 전체의 무게 중심은 '모멘트의 합' 원리(가중 평균)를 사용하여 계산합니다. 이는 컨테이너를 포함한 선박 위의 모든 무게 요소들을 고려해야 함을 의미합니다.
  - 선박 전체의 무게 중심은 **(1) 선박 자체**와 **(2) 적재된 모든 컨테이너**를 각각의 독립된 무게 요소로 보고, 이들의 가중 평균을 구하여 계산합니다. **'컨테이너가 실린 베이'의 무게 중심과 같은 중간 단계는 계산할 필요가 없습니다.**
- **기본 공식:** `전체 무게 중심 = (Σ (개별 무게 × 개별 무게 중심)) / (Σ 개별 무게)`

- **계산 단계 (LCG 예시):**
  1.  **선박 자체의 모멘트 계산:** 모든 베이(`i`)에 대해 `bay_lightship_weight[i] × bay_lcg[i]`를 계산하여 모두 더합니다.
  2.  **화물(컨테이너)의 모멘트 계산:** 선박에 실린 모든 컨테이너(`c`)에 대해, 해당 컨테이너의 무게(`c.weight`)와 컨테이너가 놓인 위치의 LCG(`location_lcg[c.location]`)를 곱하여 모두 더합니다.
  3.  **총 모멘트:** `(1번 값) + (2번 값)`
  4.  **총 무게:** `(모든 bay_lightship_weight의 합) + (모든 컨테이너 무게의 합)`
  5.  **최종 LCG:** `(3번 값) / (4번 값)`

- **VCG, TCG 계산:** 수직(`VCG`), 횡방향(`TCG`) 무게 중심 또한 위와 동일한 구조의 공식으로 계산됩니다. 각 공식에서 `lcg` 대신 `vcg` 또는 `tcg` 값을 사용하면 됩니다.
- **제약 조건 확인:** 이렇게 계산된 `LCG_ship`, `VCG_ship`, `TCG_ship` 값이 위에서 정의된 각 항구의 한계 범위 안에 들어가는지 확인해야 합니다.

### 15. 컨테이너 유형 정의 (`container_types`)
- **설명:** 인스턴스에서 사용되는 모든 컨테이너 유형의 상세 속성을 정의합니다.
- **파일 내용 (`n_container_types`줄):** 각 줄은 하나의 컨테이너 유형을 정의합니다.
  - **구성:** `길이(Int)` `무게(Float)` `종류(String)`
  - **종류 (Type) 값:**
    - `DC`: 일반 컨테이너 (Dry Container)
    - `HC`: 하이큐브 컨테이너 (High-Cube Container)
    - `RC`: 냉동 컨테이너 (Reefer Container)
    - `HR`: 하이큐브 냉동 컨테이너 (High-Cube Reefer)

### 16. 운송 구간별 컨테이너 수량 (`containers`)
- **설명:** 각 운송 구간(선적항 -> 양하항)별로 운송해야 할 컨테이너의 수량을 **유형별로** 정의합니다.
- **파일 내용 (각 유효한 구간마다 1줄):**
  - **구성:** `선적항ID` `양하항ID` `유형1개수` `유형2개수` ...
  - 선적항(Origin) ID는 양하항(Destination) ID보다 항상 작습니다.
- **컨테이너 속성(무게, 크기) 확인 방법:**
  - 이 섹션의 값들은 **컨테이너의 개수**만을 나타냅니다. 각 컨테이너의 실제 무게, 크기, 종류 등의 속성을 확인하려면, **해당 순서(인덱스)를 가지고 바로 위 `[15. 컨테이너 유형 정의]` 섹션을 참조**해야 합니다.
  - 예를 들어, 이 섹션의 한 줄에서 4번째 숫자(즉, 2번 유형의 컨테이너 개수)가 8개라면, 이 8개 컨테이너의 무게는 `container_types` 목록의 2번째 줄에 정의된 무게 값을 따릅니다.

### 17. 초기 선적 컨테이너 정보 (`release`)
- **설명:** 계획 시작 시점(첫 항구)에 이미 선박에 실려 있는 컨테이너의 정보입니다.
- **파일 내용 (각 (양하항, 로케이션) 조합마다 1줄):**
  - **구성:** `양하항ID` `로케이션ID` `유형1개수` `유형2개수` ...
  - 이 데이터는 첫 항구를 제외한 모든 양하항과 모든 로케이션의 조합에 대해 주어집니다.

